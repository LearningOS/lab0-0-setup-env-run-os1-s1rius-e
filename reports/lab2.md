## 简单总结你实现的功能

在原有框架基础上，通过增加页表和地址相关的实现、完善错误判断，完成了sys_get_time、sys_task_info的重写以及mmap、munmap匿名映射接口。

## 问答题

1. 请列举SV39页表页表项的组成，描述其中的标志位有何作用？
SV39页表的页表项中[63:52]是预留位，[53:10]是物理页号，[9:8]是预留给S特权级软件的，[7:0]是标志位。其中标志位作用如下：
+ V(Valid): 有效位，仅当该位为1时页表项才合法。
+ R(Read)/W(Write)/X(eXecute): 分别控制索引到这个页表项的对应虚拟页面是否运行读/写/执行。
+ U(User): 控制索引到这个页表项的对应虚拟页面是否允许在CPU处于U特权级时被访问。
+ G(Global): 暂且不理会。
+ A(Accessed): 处理器记录自从页表项上的这一位被清零后，页表项的对应虚拟页面是否被访问过。
+ D(Dirty): 处理器记录自从页表项上的这一位被清零后，页表项的对应虚拟页面是否被修改过，与A一起用于实现超越物理内存的机制。

2. 缺页(指进程访问页面时页面不在页表中或在页表中无效的现象)
+ 缺页可能导致的异常：LoadPageFault、StorePageFault。
+ 发生缺页时描述相关重要寄存器的值：缺页时会触发缺页异常进入内核态，scause会记录trap的原因，stval记录附加信息。
+ 程序代码在第一次被执行时才完成从磁盘到内存的加载的好处(Lazy策略)：可以减少内存的占用，使得物理内存可以更高效地被利用，扩大了虚拟的内存容量。
+ 处理10G连续的内存页面，对应SV39页表大致占用多少内存：大致占用10x1024x1024/512 = 20480字节 = 20MiB。
+ 简单思考如何实现Lazy策略，缺页时又如何处理：在用户进程申请内存空间时不立即进行页表操作，而是延后到进程实际使用时触发缺页异常，此时再将要使用的缺失页表补上。
+ 内存页面被换到磁盘上导致缺页(swap策略)时页面失效如何表现在页表项(PTE)上：将PTE中的V标志位置为0，使当前页表失效。

3. 双页表与单页表(单页表指用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问；我们的os使用了双页表)
+ 单页表如何更换页表：更换页表的方式是相似的，但应用的内核栈不再保存在内核空间中，而是在创建进程时给出该内核栈对应当前页表的入口。
+ 单页表如何控制用户态无法访问内核页面：通过PTE中的U标志位来控制，当值为0时用户态无法访问。
+ 单页表有何优势：节省页表；更利于多个进程的加载，避免内核地址空间不足导致无法初始化进程。
+ 双页表何时需要更换页表？假如你写一个单页表操作系统，会选择何时更换页表：双页表在保存和恢复Trap上下文的过程中需要切换页表；单页表操作系统会在切换应用时切换页表。
